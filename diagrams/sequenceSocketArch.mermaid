sequenceDiagram
    participant Client1 as Client 1 (User A)
    participant Client2 as Client 2 (User B)
    participant Gateway as WebSocket Gateway
    participant Redis as Redis Pub/Sub
    participant EventProc as Event Processor Service
    participant AuthDB as Auth/Permissions DB
    participant SessionCache as Redis Session Cache

    Note over Client1,SessionCache: 1. Подключение и авторизация
    Client1->>Gateway: connect(token, roomId)
    Gateway->>Redis: Validate token
    Redis->>Gateway: userId, metadata
    Gateway->>SessionCache: Store socket mapping<br/>socket:userA:room123 → socketId1
    Gateway-->>Client1: Connected

    Client2->>Gateway: connect(token, roomId)
    Gateway->>SessionCache: Store socket mapping<br/>socket:userB:room123 → socketId2
    Gateway-->>Client2: Connected

    Note over Client1,SessionCache: 2. Пользователь A двигает курсор
    Client1->>Gateway: cursor:move {roomId, x, y}
    
    Note over Gateway: Gateway НЕ принимает решений<br/>просто публикует событие
    Gateway->>Redis: PUBLISH events:cursor:move<br/>{userId: A, socketId: 1, roomId, payload}

    Note over EventProc: Event Processor слушает события
    Redis->>EventProc: events:cursor:move

    Note over EventProc,AuthDB: 3. Проверка доступов и определение получателей
    EventProc->>AuthDB: getAuthorizedUsersInRoom(room123)
    AuthDB-->>EventProc: [userA, userB, userC]
    
    EventProc->>SessionCache: getSocketIds([userA, userB, userC])
    SessionCache-->>EventProc: [socketId1, socketId2, null]

    Note over EventProc: Фильтруем отправителя<br/>и формируем broadcast

    EventProc->>Redis: PUBLISH events:broadcast:cursor<br/>{type: cursor:moved,<br/>recipients: [socketId2],<br/>payload: {userId: A, x, y}}

    Note over Gateway: Gateway слушает broadcast события
    Redis->>Gateway: events:broadcast:cursor

    Note over Gateway: Отправляем только указанным получателям
    Gateway->>Client2: cursor:moved {userId: A, x, y}

    Note over Client1,SessionCache: 4. Сложное событие (сохранение canvas)
    Client1->>Gateway: canvas:save {roomId, data}
    Gateway->>Redis: PUBLISH events:canvas:save<br/>{userId: A, socketId: 1, roomId, payload}
    
    Redis->>EventProc: events:canvas:save
    EventProc->>AuthDB: checkWritePermission(userA, room123)
    
    alt Доступ разрешен
        AuthDB-->>EventProc: true
        EventProc->>EventProc: Сохранение в БД
        EventProc->>Redis: PUBLISH events:broadcast:canvas<br/>{recipients: [all in room]}
        Redis->>Gateway: events:broadcast:canvas
        Gateway->>Client1: canvas:saved {success: true}
        Gateway->>Client2: canvas:updated {data}
    else Доступ запрещен
        AuthDB-->>EventProc: false
        EventProc->>Redis: PUBLISH events:broadcast:error<br/>{recipients: [socketId1]}
        Redis->>Gateway: events:broadcast:error
        Gateway->>Client1: error {message: Access denied}
    end

    Note over Client1,SessionCache: 5. Динамическая инвалидация доступа
    Note over AuthDB: Админ отзывает доступ userB к room123
    AuthDB->>EventProc: AccessRevoked event
    EventProc->>SessionCache: DELETE socket:userB:room123
    EventProc->>Redis: PUBLISH events:broadcast:disconnect<br/>{recipients: [socketId2], reason}
    Redis->>Gateway: events:broadcast:disconnect
    Gateway->>Client2: disconnect {reason: Access revoked}
    Gateway->>SessionCache: Remove socketId2 from room123